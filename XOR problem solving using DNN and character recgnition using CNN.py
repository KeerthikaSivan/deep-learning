# -*- coding: utf-8 -*-
"""Untitled18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B6Yvavf5OTxTPZzD5yyY_JZ0u7U6b4PV

implementation of solving XOR problem using DNN
"""

import numpy as np
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

# XOR inputs and outputs
X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])  # Inputs
y = np.array([0, 1, 1, 0])  # Outputs (XOR truth table)

# Define the model
model = Sequential()

# Add the first hidden layer with 2 neurons and ReLU activation
model.add(Dense(2, input_dim=2, activation='relu'))

# Add the second hidden layer with 2 neurons and ReLU activation
model.add(Dense(2, activation='relu'))

# Add the output layer with 1 neuron and sigmoid activation for binary output
model.add(Dense(1, activation='sigmoid'))

# Compile the model with binary crossentropy loss and Adam optimizer
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Train the model for 1000 epochs
model.fit(X, y, epochs=1000, verbose=0)

# Evaluate the model accuracy
loss, accuracy = model.evaluate(X, y, verbose=0)
print(f'Accuracy: {accuracy * 100:.2f}%')

# Make predictions on the XOR inputs
predictions = model.predict(X)

# Print the rounded predictions (rounded to 0 or 1)
print("Predicted XOR outputs:")
print(np.round(predictions))  # Round predictions to the nearest integer (0 or 1)

"""implementation of character recoginition using CNN"""

pip install tensorflow numpy matplotlib

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import numpy as np
import matplotlib.pyplot as plt

# Load the MNIST dataset
(x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()

# Normalize pixel values to the [0, 1] range
x_train = x_train.astype('float32') / 255.0
x_test = x_test.astype('float32') / 255.0

# Reshape data to add channel dimension (required for CNNs)
x_train = x_train[..., np.newaxis]  # Shape: (60000, 28, 28, 1)
x_test = x_test[..., np.newaxis]    # Shape: (10000, 28, 28, 1)

print(f"Training data shape: {x_train.shape}")
print(f"Test data shape: {x_test.shape}")

# Build the model
model = keras.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(10, activation='softmax')  # 10 classes for digits 0-9
])

# Compile the model
model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

# Train the model
history = model.fit(
    x_train, y_train,
    epochs=5,
    batch_size=128,
    validation_split=0.1  # Corrected the syntax
)

# Evaluate the model on the test set
test_loss, test_acc = model.evaluate(x_test, y_test, verbose=2)
print(f"Test accuracy: {test_acc:.4f}")

# Make predictions
predictions = model.predict(x_test)

# Predict the label of the first test image
predicted_label = np.argmax(predictions[0])
true_label = y_test[0]
print(f"Predicted label: {predicted_label}")
print(f"True label: {true_label}")

# Function to plot an image with its prediction
def plot_image(i, predictions_array, true_labels, images):
    predictions_array, true_label, img = predictions_array[i], true_labels[i], images[i]
    plt.grid(False)
    plt.xticks([])
    plt.yticks([])
    plt.imshow(img.squeeze(), cmap=plt.cm.binary)

    predicted_label = np.argmax(predictions_array)
    color = 'blue' if predicted_label == true_label else 'red'

    plt.xlabel(f"{predicted_label} ({100*np.max(predictions_array):.2f}%)", color=color)

# Plot the first 15 test images and their predictions
num_rows, num_cols = 3, 5
plt.figure(figsize=(2 * num_cols, 2 * num_rows))

for i in range(num_rows * num_cols):
    plt.subplot(num_rows, num_cols, i + 1)
    plot_image(i, predictions, y_test, x_test)

plt.tight_layout()
plt.show()

